Comment.Single:  "# numbers"
Text:  "<newline>"
Literal.Number.Integer:  "291"
Text:  "         "
Comment.Single:  "# integer"
Text:  "<newline>"
Literal.Number.Bin:  "0b100100011"
Text:  " "
Comment.Single:  "# binary"
Text:  "<newline>"
Literal.Number.Oct:  "0o443"
Text:  "       "
Comment.Single:  "# octal"
Text:  "<newline>"
Literal.Number.Hex:  "0x123"
Text:  "       "
Comment.Single:  "# hexadecimal"
Text:  "<newline>"
Literal.Number.Float:  "291.0"
Text:  "       "
Comment.Single:  "# float"
Text:  "<newline><newline>"
Comment.Single:  "# keywords with no following whitespace"
Text:  "<newline>"
Punctuation:  "("
Keyword:  "cond"
Punctuation:  ")"
Text:  "<newline>"
Punctuation:  "("
Keyword:  "do"
Punctuation:  ")"
Text:  "<newline>"
Punctuation:  "("
Keyword:  "end"
Punctuation:  ")"
Text:  "<newline><newline>"
Comment.Single:  "# bitwise operators"
Text:  "<newline>"
Operator:  "~~~"
Literal.Number.Integer:  "1"
Text:  "<newline>"
Literal.Number.Integer:  "2"
Text:  " "
Operator:  "&&&"
Text:  " "
Literal.Number.Integer:  "3"
Text:  "<newline><newline>"
Comment.Single:  "# structs"
Text:  "<newline>"
Punctuation:  "%"
Name.Constant:  "Struct"
Punctuation:  "{"
Text:  "  "
Punctuation:  "}"
Text:  "<newline><newline>"
Comment.Single:  "# maps"
Text:  "<newline>"
Punctuation:  "%{"
Literal.String.Symbol:  "key:"
Text:  " "
Literal.Number.Integer:  "1"
Punctuation:  "}"
Text:  "<newline><newline>"
Comment.Single:  "# strings"
Text:  "<newline>"
Literal.String.Double:  "\"Hello world\""
Text:  "<newline>"
Literal.String.Double:  "\"Hello "
Literal.String.Escape:  "\\\""
Literal.String.Double:  " world\""
Text:  "<newline>"
Literal.String.Double:  "\"Hello "
Literal.String.Escape:  "<newline>"
Literal.String.Double:  " world\""
Text:  "<newline>"
Literal.String.Double:  "\"Hello "
Literal.String.Interpol:  "\#{"
Literal.String.Double:  "\"world\""
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Text:  "<newline>"
Literal.String.Double:  "\"Hello #world\""
Text:  "<newline><newline>"
Comment.Single:  "# charlists"
Text:  "<newline>"
Literal.String.Single:  "'Hello world'"
Text:  "<newline>"
Literal.String.Single:  "'Hello "
Literal.String.Escape:  "\\'"
Literal.String.Single:  " world'"
Text:  "<newline>"
Literal.String.Single:  "'Hello "
Literal.String.Escape:  "<newline>"
Literal.String.Single:  " world'"
Text:  "<newline>"
Literal.String.Single:  "'Hello "
Literal.String.Interpol:  "\#{"
Literal.String.Single:  "'world'"
Literal.String.Interpol:  "}"
Literal.String.Single:  "'"
Text:  "<newline>"
Literal.String.Single:  "'Hello #world'"
Text:  "<newline><newline>"
Comment.Single:  "# regexes"
Text:  "<newline>"
Literal.String.Regex:  "~r()gif"
Text:  "<newline>"
Literal.String.Regex:  "~r[]gfi"
Text:  "<newline>"
Literal.String.Regex:  "~r<>fgi"
Text:  "<newline>"
Literal.String.Regex:  "~r''fig"
Text:  "<newline>"
Literal.String.Regex:  "~r\"\"igf"
Text:  "<newline>"
Literal.String.Regex:  "~r||i"
Text:  "<newline>"
Literal.String.Regex:  "~r//g"
Text:  "<newline><newline>"
Literal.String.Regex:  "~r()"
Text:  "<newline>"
Literal.String.Regex:  "~r[]"
Text:  "<newline>"
Literal.String.Regex:  "~r<>"
Text:  "<newline>"
Literal.String.Regex:  "~r''"
Text:  "<newline>"
Literal.String.Regex:  "~r\"\""
Text:  "<newline>"
Literal.String.Regex:  "~r||"
Text:  "<newline>"
Literal.String.Regex:  "~r//"
Name:  "variable"
Text:  "<newline><newline>"
Comment.Single:  "# avoids greedy errors"
Text:  "<newline>"
Name:  "string"
Text:  " "
Operator:  "|>"
Text:  " "
Name.Constant:  "String"
Operator:  "."
Name:  "split"
Punctuation:  "("
Literal.String.Regex:  "~r/[ -]/"
Punctuation:  ")"
Text:  " "
Operator:  "|>"
Text:  " "
Name.Constant:  "Enum"
Operator:  "."
Name:  "map"
Punctuation:  "("
Operator:  "&"
Name:  "abbreviate_word"
Operator:  "/"
Literal.Number.Integer:  "1"
Punctuation:  ")"
Text:  " "
Operator:  "|>"
Text:  " "
Name.Constant:  "Enum"
Operator:  "."
Name:  "join"
Punctuation:  "()"
Text:  "<newline><newline>"
Comment.Single:  "# sigils"
Text:  "<newline>"
Literal.String.Other:  "~c()"
Text:  "<newline>"
Literal.String.Other:  "~c[]"
Text:  "<newline>"
Literal.String.Other:  "~c<>"
Text:  "<newline>"
Literal.String.Other:  "~c''"
Text:  "<newline>"
Literal.String.Other:  "~c\"\""
Text:  "<newline>"
Literal.String.Other:  "~c||"
Text:  "<newline>"
Literal.String.Other:  "~c//"
Text:  "<newline><newline>"
Literal.String.Other:  "~S(inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n)"
Text:  "<newline>"
Literal.String.Other:  "~S[inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n]"
Text:  "<newline>"
Literal.String.Other:  "~S<inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n>"
Text:  "<newline>"
Literal.String.Other:  "~S'inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n'"
Text:  "<newline>"
Literal.String.Other:  "~S\"inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n\""
Text:  "<newline>"
Literal.String.Other:  "~S|inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n|"
Text:  "<newline>"
Literal.String.Other:  "~S/inter "
Literal.String.Interpol:  "\#{"
Name:  "pol"
Text:  " "
Operator:  "<>"
Text:  " "
Literal.String.Double:  "\"ati"
Literal.String.Interpol:  "\#{"
Name:  "o"
Literal.String.Interpol:  "}"
Literal.String.Double:  "\""
Literal.String.Interpol:  "}"
Literal.String.Other:  " n/"
Text:  "<newline><newline>"
Comment.Single:  "# first is Operator, second is &1 variable"
Text:  "<newline>"
Operator:  "&"
Punctuation:  "("
Name.Variable:  "&1"
Punctuation:  ")"
Text:  "<newline><newline>"
Comment.Single:  "# We cannot use to_char_list because it depends on inspect,"
Text:  "<newline>"
Comment.Single:  "# which depends on protocol, which depends on this module."
Text:  "<newline>"
Keyword.Namespace:  "import"
Text:  " "
Name.Constant:  "Elixir"
Punctuation:  "::"
Name.Constant:  "Builtin"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  "except:"
Text:  " "
Punctuation:  "["
Literal.String.Symbol:  "to_char_list:"
Text:  " "
Literal.Number.Integer:  "1"
Punctuation:  "]"
Text:  "<newline><newline>"
Keyword:  "defmodule"
Text:  " "
Name.Constant:  "Module"
Text:  " "
Keyword:  "do"
Text:  "<newline>  "
Keyword.Namespace:  "require"
Text:  " "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "ets"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  "as:"
Text:  " "
Name.Constant:  "ETS"
Text:  "<newline><newline>  "
Name.Variable:  "@moduledoc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  This module provides many functions to deal with modules during<newline>  compilation time. It allows a developer to dynamically attach<newline>  documentation, merge data, register attributes and so forth.<newline><newline>  After the module is compiled, using many of the functions in<newline>  this module will raise errors, since it is out of their purpose<newline>  to inspect runtime data. Most of the runtime data can be inspected<newline>  via the `__info__(attr)` function attached to each compiled module.<newline>  \"\"\""
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Evalutes the quotes contents in the given module context.<newline>  Raises an error if the module was already compiled.<newline><newline>  ## Examples<newline><newline>      defmodule Foo do<newline>        contents = quote do: (def sum(a, b), do: a + b)<newline>        Module.eval_quoted __MODULE__, contents, [], __FILE__, __LINE__<newline>      end<newline><newline>      Foo.sum(1, 2) #=> 3<newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "eval_quoted"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "quoted"
Punctuation:  ","
Text:  " "
Name:  "binding"
Punctuation:  ","
Text:  " "
Name:  "filename"
Punctuation:  ","
Text:  " "
Name:  "line"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":eval_quoted"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Punctuation:  "{"
Text:  " "
Name:  "binding"
Punctuation:  ","
Text:  " "
Name:  "scope"
Text:  " "
Punctuation:  "}"
Text:  " "
Operator:  "="
Text:  " "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "elixir_module"
Operator:  "."
Name:  "binding_and_scope_for_eval"
Punctuation:  "("
Name:  "line"
Punctuation:  ","
Text:  " "
Name:  "to_char_list"
Punctuation:  "("
Name:  "filename"
Punctuation:  "),"
Text:  " "
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "binding"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "elixir_def"
Operator:  "."
Name:  "reset_last"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "elixir"
Operator:  "."
Name:  "eval_quoted"
Punctuation:  "(["
Name:  "quoted"
Punctuation:  "],"
Text:  " "
Name:  "binding"
Punctuation:  ","
Text:  " "
Name:  "line"
Punctuation:  ","
Text:  " "
Name:  "scope"
Punctuation:  ")"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Checks if the module is compiled or not.<newline><newline>  ## Examples<newline><newline>      defmodule Foo do<newline>        Module.compiled?(__MODULE__) #=> false<newline>      end<newline><newline>      Module.compiled?(Foo) #=> true<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "compiled?"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "=="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "info"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":name"
Punctuation:  ")"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Reads the data for the given module. This is used<newline>  to read data of uncompiled modules. If the module<newline>  was already compiled, you shoul access the data<newline>  directly by invoking `__info__(:data)` in that module.<newline><newline>  ## Examples<newline><newline>      defmodule Foo do<newline>        Module.merge_data __MODULE__, value: 1<newline>        Module.read_data __MODULE__ #=> [value: 1]<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "read_data"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":read_data"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  "),"
Text:  " "
Literal.String.Symbol:  ":data"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Reads the data from `module` at the given key `at`.<newline><newline>  ## Examples<newline><newline>      defmodule Foo do<newline>        Module.merge_data __MODULE__, value: 1<newline>        Module.read_data __MODULE__, :value #=> 1<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "read_data"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "at"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name.Constant:  "Orddict"
Operator:  "."
Name:  "get"
Text:  " "
Name:  "read_data"
Punctuation:  "("
Name:  "module"
Punctuation:  "),"
Text:  " "
Name:  "at"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Merge the given data into the module, overriding any<newline>  previous one.<newline><newline>  If any of the given data is a registered attribute, it is<newline>  automatically added to the attribute set, instead of marking<newline>  it as data. See register_attribute/2 and add_attribute/3 for<newline>  more info.<newline><newline>  ## Examples<newline><newline>      defmodule Foo do<newline>        Module.merge_data __MODULE__, value: 1<newline>      end<newline><newline>      Foo.__info__(:data) #=> [value: 1]<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "merge_data"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "data"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":merge_data"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline><newline>    "
Name:  "table"
Text:  "      "
Operator:  "="
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "old"
Text:  "        "
Operator:  "="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":data"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "registered"
Text:  " "
Operator:  "="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":registered_attributes"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline><newline>    "
Punctuation:  "{"
Text:  " "
Name:  "attrs"
Punctuation:  ","
Text:  " "
Name:  "new"
Text:  " "
Punctuation:  "}"
Text:  " "
Operator:  "="
Text:  " "
Name.Constant:  "Enum"
Operator:  "."
Name:  "partition"
Text:  " "
Name:  "data"
Punctuation:  ","
Text:  " "
Keyword:  "fn"
Punctuation:  "({"
Name:  "k"
Punctuation:  ","
Name:  "_"
Punctuation:  "})"
Text:  " "
Operator:  "->"
Text:  " "
Name.Constant:  "List"
Operator:  "."
Name:  "member?"
Punctuation:  "("
Name:  "registered"
Punctuation:  ","
Text:  " "
Name:  "k"
Punctuation:  ")"
Text:  " "
Keyword:  "end"
Text:  "<newline>    "
Name.Constant:  "Enum"
Operator:  "."
Name:  "each"
Text:  " "
Name:  "attrs"
Punctuation:  ","
Text:  " "
Keyword:  "fn"
Punctuation:  "({"
Name:  "k"
Punctuation:  ","
Name:  "v"
Punctuation:  "})"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "add_attribute"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "k"
Punctuation:  ","
Text:  " "
Name:  "v"
Punctuation:  ")"
Text:  " "
Keyword:  "end"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "insert"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  " "
Literal.String.Symbol:  ":data"
Punctuation:  ","
Text:  "  "
Name.Constant:  "Orddict"
Operator:  "."
Name:  "merge"
Punctuation:  "("
Name:  "old"
Punctuation:  ","
Text:  " "
Name:  "new"
Punctuation:  ")"
Text:  " "
Punctuation:  "})"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Attaches documentation to a given function. It expects<newline>  the module the function belongs to, the line (a non negative<newline>  integer), the kind (def or defmacro), a tuple representing<newline>  the function and its arity and the documentation, which should<newline>  be either a binary or a boolean.<newline><newline>  ## Examples<newline><newline>      defmodule MyModule do<newline>        Module.add_doc(__MODULE__, __LINE__ + 1, :def, { :version, 0 }, \"Manually added docs\")<newline>        def version, do: 1<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "add_doc"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "line"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  ","
Text:  " "
Name:  "tuple"
Punctuation:  ","
Text:  " "
Name:  "doc"
Punctuation:  ")"
Text:  " "
Operator.Word:  "when"
Text:  "<newline>      "
Name:  "is_binary"
Punctuation:  "("
Name:  "doc"
Punctuation:  ")"
Text:  " "
Operator.Word:  "or"
Text:  " "
Name:  "is_boolean"
Punctuation:  "("
Name:  "doc"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":add_doc"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Keyword:  "case"
Text:  " "
Name:  "kind"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Literal.String.Symbol:  "match:"
Text:  " "
Literal.String.Symbol:  ":defp"
Text:  "<newline>      "
Literal.String.Symbol:  ":warn"
Text:  "<newline>    "
Keyword:  "else"
Punctuation:  ":"
Text:  "<newline>      "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "docs_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>      "
Name.Constant:  "ETS"
Operator:  "."
Name:  "insert"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  " "
Name:  "tuple"
Punctuation:  ","
Text:  " "
Name:  "line"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  ","
Text:  " "
Name:  "doc"
Text:  " "
Punctuation:  "})"
Text:  "<newline>      "
Literal.String.Symbol:  ":ok"
Text:  "<newline>    "
Keyword:  "end"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Checks if a function was defined, regardless if it is<newline>  a macro or a private function. Use function_defined?/3<newline>  to assert for an specific type.<newline><newline>  ## Examples<newline><newline>      defmodule Example do<newline>        Module.function_defined? __MODULE__, { :version, 0 } #=> false<newline>        def version, do: 1<newline>        Module.function_defined? __MODULE__, { :version, 0 } #=> true<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "function_defined?"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "tuple"
Punctuation:  ")"
Text:  " "
Operator.Word:  "when"
Text:  " "
Name:  "is_tuple"
Punctuation:  "("
Name:  "tuple"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":function_defined?"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "function_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Name:  "tuple"
Punctuation:  ")"
Text:  " "
Operator:  "!="
Text:  " "
Punctuation:  "[]"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Checks if a function was defined and also for its `kind`.<newline>  `kind` can be either :def, :defp or :defmacro.<newline><newline>  ## Examples<newline><newline>      defmodule Example do<newline>        Module.function_defined? __MODULE__, { :version, 0 }, :defp #=> false<newline>        def version, do: 1<newline>        Module.function_defined? __MODULE__, { :version, 0 }, :defp #=> false<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "function_defined?"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "tuple"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name.Constant:  "List"
Operator:  "."
Name:  "member?"
Text:  " "
Name:  "defined_functions"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  "),"
Text:  " "
Name:  "tuple"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Return all functions defined in the given module.<newline><newline>  ## Examples<newline><newline>      defmodule Example do<newline>        def version, do: 1<newline>        Module.defined_functions __MODULE__ #=> [{:version,1}]<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "defined_functions"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":defined_functions"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "function_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Keyword:  "lc"
Text:  " "
Punctuation:  "{"
Text:  " "
Name:  "tuple"
Punctuation:  ","
Text:  " "
Name:  "_"
Punctuation:  ","
Text:  " "
Name:  "_"
Text:  " "
Punctuation:  "}"
Text:  " "
Operator.Word:  "in"
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "tab2list"
Punctuation:  "("
Name:  "table"
Punctuation:  "),"
Text:  " "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Name:  "tuple"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Returns all functions defined in te given module according<newline>  to its kind.<newline><newline>  ## Examples<newline><newline>      defmodule Example do<newline>        def version, do: 1<newline>        Module.defined_functions __MODULE__, :def  #=> [{:version,1}]<newline>        Module.defined_functions __MODULE__, :defp #=> []<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "defined_functions"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":defined_functions"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "function_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "entry"
Text:  " "
Operator:  "="
Text:  " "
Name:  "kind_to_entry"
Punctuation:  "("
Name:  "kind"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Name:  "entry"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Adds a compilation callback hook that is invoked<newline>  exactly before the module is compiled.<newline><newline>  This callback is useful when used with `use` as a mechanism<newline>  to clean up any internal data in the module before it is compiled.<newline><newline>  ## Examples<newline><newline>  Imagine you are creating a module/library that is meant for<newline>  external usage called `MyLib`. It could be defined as:<newline><newline>      defmodule MyLib do<newline>        def __using__(target) do<newline>          Module.merge_data target, some_data: true<newline>          Module.add_compile_callback(target, __MODULE__, :__callback__)<newline>        end<newline><newline>        defmacro __callback__(target) do<newline>          value = Orddict.get(Module.read_data(target), :some_data, [])<newline>          quote do: (def my_lib_value, do: unquote(value))<newline>        end<newline>      end<newline><newline>  And a module could use `MyLib` with:<newline><newline>      defmodule App do<newline>        use ModuleTest::ToBeUsed<newline>      end<newline><newline>  In the example above, `MyLib` defines a data to the target. This data<newline>  can be updated throughout the module definition and therefore, the final<newline>  value of the data can only be compiled using a compiation callback,<newline>  which will read the final value of :some_data and compile to a function.<newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "add_compile_callback"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "target"
Punctuation:  ","
Text:  " "
Name:  "fun"
Text:  " "
Operator:  "//"
Text:  " "
Literal.String.Symbol:  ":__compiling__"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":add_compile_callback"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "new"
Text:  "   "
Operator:  "="
Text:  " "
Punctuation:  "{"
Text:  " "
Name:  "target"
Punctuation:  ","
Text:  " "
Name:  "fun"
Text:  " "
Punctuation:  "}"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "old"
Text:  "   "
Operator:  "="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":compile_callbacks"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "insert"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  " "
Literal.String.Symbol:  ":compile_callbacks"
Punctuation:  ","
Text:  "  "
Punctuation:  "["
Name:  "new"
Operator:  "|"
Name:  "old"
Punctuation:  "]"
Text:  " "
Punctuation:  "})"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Adds an Erlang attribute to the given module with the given<newline>  key and value. The same attribute can be added more than once.<newline><newline>  ## Examples<newline><newline>      defmodule MyModule do<newline>        Module.add_attribute __MODULE__, :custom_threshold_for_lib, 10<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "add_attribute"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "key"
Punctuation:  ","
Text:  " "
Name:  "value"
Punctuation:  ")"
Text:  " "
Operator.Word:  "when"
Text:  " "
Name:  "is_atom"
Punctuation:  "("
Name:  "key"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":add_attribute"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "attrs"
Text:  " "
Operator:  "="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":attributes"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "insert"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  " "
Literal.String.Symbol:  ":attributes"
Punctuation:  ","
Text:  " "
Punctuation:  "[{"
Name:  "key"
Punctuation:  ","
Text:  " "
Name:  "value"
Punctuation:  "}"
Operator:  "|"
Name:  "attrs"
Punctuation:  "]"
Text:  " "
Punctuation:  "})"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Deletes all attributes that matches the given key.<newline><newline>  ## Examples<newline><newline>      defmodule MyModule do<newline>        Module.add_attribute __MODULE__, :custom_threshold_for_lib, 10<newline>        Module.delete_attribute __MODULE__, :custom_threshold_for_lib<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "delete_attribute"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "key"
Punctuation:  ")"
Text:  " "
Operator.Word:  "when"
Text:  " "
Name:  "is_atom"
Punctuation:  "("
Name:  "key"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":delete_attribute"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "attrs"
Text:  " "
Operator:  "="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":attributes"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "final"
Text:  " "
Operator:  "="
Text:  " "
Keyword:  "lc"
Text:  " "
Punctuation:  "{"
Name:  "k"
Punctuation:  ","
Name:  "v"
Punctuation:  "}"
Text:  " "
Operator.Word:  "in"
Text:  " "
Name:  "attrs"
Punctuation:  ","
Text:  " "
Name:  "k"
Text:  " "
Operator:  "!="
Text:  " "
Name:  "key"
Punctuation:  ","
Text:  " "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Punctuation:  "{"
Name:  "k"
Punctuation:  ","
Name:  "v"
Punctuation:  "}"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "insert"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  " "
Literal.String.Symbol:  ":attributes"
Punctuation:  ","
Text:  " "
Name:  "final"
Text:  " "
Punctuation:  "})"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Literal.String.Doc:  "\"\"\"<newline>  Registers an attribute. This allows a developer to use the data API<newline>  but Elixir will register the data as an attribute automatically.<newline>  By default, `vsn`, `behavior` and other Erlang attributes are<newline>  automatically registered.<newline><newline>  ## Examples<newline><newline>      defmodule MyModule do<newline>        Module.register_attribute __MODULE__, :custom_threshold_for_lib<newline>        @custom_threshold_for_lib 10<newline>      end<newline><newline>  \"\"\""
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "register_attribute"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "new"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "assert_not_compiled!"
Punctuation:  "("
Literal.String.Symbol:  ":register_attribute"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "table"
Text:  " "
Operator:  "="
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  "<newline>    "
Name:  "old"
Text:  " "
Operator:  "="
Text:  " "
Name.Constant:  "ETS"
Operator:  "."
Name:  "lookup_element"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":registered_attributes"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>    "
Name.Constant:  "ETS"
Operator:  "."
Name:  "insert"
Punctuation:  "("
Name:  "table"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  " "
Literal.String.Symbol:  ":registered_attributes"
Punctuation:  ","
Text:  "  "
Punctuation:  "["
Name:  "new"
Operator:  "|"
Name:  "old"
Punctuation:  "]"
Text:  " "
Punctuation:  "})"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Name.Variable:  "@doc"
Text:  " "
Name.Constant:  "false"
Text:  "<newline>  "
Comment.Single:  "# Used internally to compile documentation. This function"
Text:  "<newline>  "
Comment.Single:  "# is private and must be used only internally."
Text:  "<newline>  "
Keyword:  "def"
Text:  " "
Name:  "compile_doc"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "line"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  ","
Text:  " "
Name:  "pair"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Keyword:  "case"
Text:  " "
Name:  "read_data"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  ":doc"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Literal.String.Symbol:  "match:"
Text:  " "
Name.Constant:  "nil"
Text:  "<newline>      "
Comment.Single:  "# We simply discard nil"
Text:  "<newline>    "
Literal.String.Symbol:  "match:"
Text:  " "
Name:  "doc"
Text:  "<newline>      "
Name:  "result"
Text:  " "
Operator:  "="
Text:  " "
Name:  "add_doc"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Name:  "line"
Punctuation:  ","
Text:  " "
Name:  "kind"
Punctuation:  ","
Text:  " "
Name:  "pair"
Punctuation:  ","
Text:  " "
Name:  "doc"
Punctuation:  ")"
Text:  "<newline>      "
Name:  "merge_data"
Punctuation:  "("
Name:  "module"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  "doc:"
Text:  " "
Name.Constant:  "nil"
Punctuation:  ")"
Text:  "<newline>      "
Name:  "result"
Text:  "<newline>    "
Keyword:  "end"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Comment.Single:  "## Helpers"
Text:  "<newline><newline>  "
Keyword:  "defp"
Text:  " "
Name:  "kind_to_entry"
Punctuation:  "("
Literal.String.Symbol:  ":def"
Punctuation:  "),"
Text:  "      "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Literal.String.Symbol:  ":public"
Text:  "<newline>  "
Keyword:  "defp"
Text:  " "
Name:  "kind_to_entry"
Punctuation:  "("
Literal.String.Symbol:  ":defp"
Punctuation:  "),"
Text:  "     "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Literal.String.Symbol:  ":private"
Text:  "<newline>  "
Keyword:  "defp"
Text:  " "
Name:  "kind_to_entry"
Punctuation:  "("
Literal.String.Symbol:  ":defmacro"
Punctuation:  "),"
Text:  " "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Literal.String.Symbol:  ":macros"
Text:  "<newline><newline>  "
Keyword:  "defp"
Text:  " "
Name:  "to_char_list"
Punctuation:  "("
Name:  "list"
Punctuation:  ")"
Text:  " "
Operator.Word:  "when"
Text:  " "
Name:  "is_list"
Punctuation:  "("
Name:  "list"
Punctuation:  "),"
Text:  "  "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Name:  "list"
Text:  "<newline>  "
Keyword:  "defp"
Text:  " "
Name:  "to_char_list"
Punctuation:  "("
Name:  "bin"
Punctuation:  ")"
Text:  "  "
Operator.Word:  "when"
Text:  " "
Name:  "is_binary"
Punctuation:  "("
Name:  "bin"
Punctuation:  "),"
Text:  " "
Keyword:  "do"
Punctuation:  ":"
Text:  " "
Name:  "binary_to_list"
Punctuation:  "("
Name:  "bin"
Punctuation:  ")"
Text:  "<newline><newline>  "
Keyword:  "defp"
Text:  " "
Name:  "data_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "list_to_atom"
Text:  " "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "lists"
Operator:  "."
Name:  "concat"
Punctuation:  "(["
Literal.String.Symbol:  ":d"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  "])"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Keyword:  "defp"
Text:  " "
Name:  "function_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "list_to_atom"
Text:  " "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "lists"
Operator:  "."
Name:  "concat"
Punctuation:  "(["
Literal.String.Symbol:  ":f"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  "])"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Keyword:  "defp"
Text:  " "
Name:  "docs_table_for"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "list_to_atom"
Text:  " "
Name.Constant:  "Erlang"
Operator:  "."
Name:  "lists"
Operator:  "."
Name:  "concat"
Punctuation:  "(["
Literal.String.Symbol:  ":o"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  "])"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline><newline>  "
Keyword:  "defp"
Text:  " "
Name:  "assert_not_compiled!"
Punctuation:  "("
Name:  "fun"
Punctuation:  ","
Text:  " "
Name:  "module"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "compiled?"
Punctuation:  "("
Name:  "module"
Punctuation:  ")"
Text:  " "
Operator:  "||"
Text:  "<newline>      "
Keyword:  "raise"
Text:  " "
Name.Constant:  "ArgumentError"
Punctuation:  ","
Text:  " "
Literal.String.Symbol:  "message:"
Text:  "<newline>        "
Literal.String.Double:  "\"could not call "
Literal.String.Interpol:  "\#{"
Name:  "fun"
Literal.String.Interpol:  "}"
Literal.String.Double:  " on module "
Literal.String.Interpol:  "\#{"
Name:  "module"
Literal.String.Interpol:  "}"
Literal.String.Double:  " because it was already compiled\""
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline>"
Keyword:  "end"
Text:  "<newline><newline>"
Keyword:  "defp"
Text:  " "
Name:  "interpret"
Punctuation:  "("
Name:  "input"
Punctuation:  ")"
Text:  " "
Keyword:  "do"
Text:  "<newline>  "
Keyword:  "cond"
Text:  " "
Keyword:  "do"
Text:  "<newline>    "
Name:  "is_empty?"
Text:  " "
Name:  "input"
Text:  " "
Operator:  "->"
Text:  " "
Literal.String.Symbol:  ":silence"
Text:  "<newline>    "
Name:  "all_caps?"
Text:  " "
Name:  "input"
Text:  " "
Operator:  "->"
Text:  " "
Literal.String.Symbol:  ":exclamation"
Text:  "<newline>    "
Name:  "question?"
Text:  " "
Name:  "input"
Text:  " "
Operator:  "->"
Text:  " "
Literal.String.Symbol:  ":question"
Text:  "<newline>    "
Name.Constant:  "true"
Text:  "            "
Operator:  "->"
Text:  " "
Literal.String.Symbol:  ":statement"
Text:  "<newline>  "
Keyword:  "end"
Text:  "<newline>"
Keyword:  "end"
Text:  "<newline><newline>"
Keyword.Namespace:  "use"
Text:  " "
Name.Constant:  "Bitwise"
Text:  "<newline>"
Operator:  "~~~"
Literal.Number.Integer:  "1"
Text:  "<newline>"
Literal.Number.Integer:  "1"
Text:  " "
Operator:  "&&&"
Text:  " "
Literal.Number.Integer:  "2"
Text:  "<newline>"
Punctuation:  "%{"
Literal.String.Symbol:  "key:"
Text:  " "
Literal.Number.Integer:  "1"
Punctuation:  "}"
Text:  "<newline>"
Punctuation:  "%"
Name.Constant:  "Struct"
Punctuation:  "{"
Literal.String.Symbol:  "name:"
Text:  " "
Literal.String.Double:  "\"value\""
Punctuation:  "}"
Text:  "<newline>"
Literal.String.Regex:  "~r/^(.+):(\\d+)$/"
Text:  "<newline>"
Name:  "doubler"
Text:  " "
Operator:  "="
Text:  " "
Operator:  "&"
Punctuation:  "("
Name.Variable:  "&1"
Text:  " "
Operator:  "*"
Text:  " "
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  "<newline>"
