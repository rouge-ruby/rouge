Comment:  "% Percent sign start a one-line comment.<newline>"
Text:  "<newline>"
Comment:  "%% Two percent characters shall be used to comment functions.<newline>"
Text:  "<newline>"
Comment:  "%%% Three percent characters shall be used to comment modules.<newline>"
Text:  "<newline>"
Comment:  "% We use three types of punctuation in Erlang.<newline>% Commas (`,`) separate arguments in function calls, data constructors, and<newline>% patterns.<newline>% Periods (`.`) (followed by whitespace) separate entire functions and<newline>% expressions in the shell.<newline>% Semicolons (`;`) separate clauses. We find clauses in several contexts: in kn<newline>% function definitions and in `case`, `if`, `try..catch` and `receive`<newline>% expressions.<newline>"
Text:  "<newline>"
Comment:  "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<newline>%% 1. Variables and pattern matching.<newline>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<newline>"
Text:  "<newline>"
Name.Variable:  "Num"
Text:  " "
Operator:  "="
Text:  " "
Literal.Number.Integer:  "42"
Punctuation:  "."
Text:  "  "
Comment:  "% All variable names must start with an uppercase letter.<newline>% Erlang has single assignment variables, if you try to assign a different value<newline>% to the variable `Num`, you\u2019ll get an error.<newline>"
Text:  "<newline>"
Comment:  "% In most languages, `=` denotes an assignment statement. In Erlang, however,<newline>% `=` denotes a pattern matching operation. `Lhs = Rhs` really means this:<newline>% evaluate the right side (Rhs), and then match the result against the pattern<newline>% on the left side (Lhs).<newline>"
Name.Variable:  "Num"
Text:  " "
Operator:  "="
Text:  " "
Literal.Number.Integer:  "7"
Text:  " "
Operator:  "*"
Text:  " "
Literal.Number.Integer:  "6"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% Floating point number.<newline>"
Name.Variable:  "Pi"
Text:  " "
Operator:  "="
Text:  " "
Literal.Number.Integer:  "3"
Punctuation:  "."
Literal.Number.Integer:  "14159"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% Atoms, are used to represent different non-numerical constant values. Atoms<newline>% start with lowercase letters, followed by a sequence of alphanumeric<newline>% characters or the underscore (`_`) or at (`@`) sign.<newline>"
Name.Variable:  "Hello"
Text:  " "
Operator:  "="
Text:  " "
Name:  "hello"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% Tuples are similar to structs in C.<newline>"
Name.Variable:  "Point"
Text:  " "
Operator:  "="
Text:  " "
Punctuation:  "{"
Name:  "point"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "10"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "45"
Punctuation:  "}."
Text:  "<newline><newline>"
Comment:  "% If we want to extract some values from a tuple, we use the pattern matching<newline>% operator `=`.<newline>"
Punctuation:  "{"
Name:  "point"
Punctuation:  ","
Text:  " "
Name.Variable:  "X"
Punctuation:  ","
Text:  " "
Name.Variable:  "Y"
Punctuation:  "}"
Text:  " "
Operator:  "="
Text:  " "
Name.Variable:  "Point"
Punctuation:  "."
Text:  "  "
Comment:  "% X = 10, Y = 45<newline>"
Text:  "<newline>"
Comment:  "% We can use `_` as a placeholder for variables that we\u2019re not interested in.<newline>% The symbol `_` is called an anonymous variable. Unlike regular variables,<newline>% several occurrences of _ in the same pattern don\u2019t have to bind to the same<newline>% value.<newline>"
Name.Variable:  "Person"
Text:  " "
Operator:  "="
Text:  " "
Punctuation:  "{"
Name:  "person"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Name:  "name"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Name:  "first"
Punctuation:  ","
Text:  " "
Name:  "joe"
Punctuation:  "},"
Text:  " "
Punctuation:  "{"
Name:  "last"
Punctuation:  ","
Text:  " "
Name:  "armstrong"
Punctuation:  "}},"
Text:  " "
Punctuation:  "{"
Name:  "footsize"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "42"
Punctuation:  "}}."
Text:  "<newline>"
Punctuation:  "{_,"
Text:  " "
Punctuation:  "{_,"
Text:  " "
Punctuation:  "{_,"
Text:  " "
Name.Variable:  "Who"
Punctuation:  "},"
Text:  " "
Punctuation:  "_},"
Text:  " "
Punctuation:  "_}"
Text:  " "
Operator:  "="
Text:  " "
Name.Variable:  "Person"
Punctuation:  "."
Text:  "  "
Comment:  "% Who = joe<newline>"
Text:  "<newline>"
Comment:  "% We create a list by enclosing the list elements in square brackets and<newline>% separating them with commas.<newline>% The individual elements of a list can be of any type.<newline>% The first element of a list the head of the list. If you imagine removing the<newline>% head from the list, what\u2019s left is called the tail of the list.<newline>"
Name.Variable:  "ThingsToBuy"
Text:  " "
Operator:  "="
Text:  " "
Punctuation:  "[{"
Name:  "apples"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "10"
Punctuation:  "},"
Text:  " "
Punctuation:  "{"
Name:  "pears"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "6"
Punctuation:  "},"
Text:  " "
Punctuation:  "{"
Name:  "milk"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "3"
Punctuation:  "}]."
Text:  "<newline><newline>"
Comment:  "% If `T` is a list, then `[H|T]` is also a list, with head H and tail T.<newline>% The vertical bar (`|`) separates the head of a list from its tail.<newline>% `[]` is the empty list.<newline>% We can extract elements from a list with a pattern matching operation. If we<newline>% have the nonempty list `L`, then the expression `[X|Y] = L`, where `X` and `Y`<newline>% are unbound variables, will extract the head of the list into `X` and the tail<newline>% of the list into `Y`.<newline>"
Punctuation:  "["
Name.Variable:  "FirstThing"
Punctuation:  "|"
Name.Variable:  "OtherThingsToBuy"
Punctuation:  "]"
Text:  " "
Operator:  "="
Text:  " "
Name.Variable:  "ThingsToBuy"
Punctuation:  "."
Text:  "<newline>"
Comment:  "% FirstThing = {apples, 10}<newline>% OtherThingsToBuy = {pears, 6}, {milk, 3}<newline>"
Text:  "<newline>"
Comment:  "% There are no strings in Erlang. Strings are really just lists of integers.<newline>% Strings are enclosed in double quotation marks (`\"`).<newline>"
Name.Variable:  "Name"
Text:  " "
Operator:  "="
Text:  " "
Literal.String:  "\"Hello\""
Punctuation:  "."
Text:  "<newline><newline><newline>"
Comment:  "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<newline>%% 2. Sequential programming.<newline>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<newline>"
Text:  "<newline>"
Comment:  "% Modules are the basic unit of code in Erlang. All the functions we write are<newline>% stored in modules. Modules are stored in files with `.erl` extensions.<newline>% Modules must be compiled before the code can be run. A compiled module has the<newline>% extension `.beam`.<newline>"
Punctuation:  "-"
Name.Entity:  "module"
Punctuation:  "("
Name:  "geometry"
Punctuation:  ")."
Text:  "<newline>"
Punctuation:  "-"
Name.Entity:  "export"
Punctuation:  "(["
Name:  "area"
Operator:  "/"
Literal.Number.Integer:  "1"
Punctuation:  "])."
Text:  "<newline><newline>"
Comment:  "% The function area consists of two clauses. The clauses are separated by a<newline>% semicolon, and the final clause is terminated by dot-whitespace.<newline>% Each clause has a head and a body; the head consists of a function name<newline>% followed by a pattern (in parentheses), and the body consists of a sequence of<newline>% expressions, which are evaluated if the pattern in the head is successfully<newline>% matched against the calling arguments. The patterns are matched in the order<newline>% they appear in the function definition.<newline>"
Name.Function:  "area"
Punctuation:  "({"
Name:  "rectangle"
Punctuation:  ","
Text:  " "
Name.Variable:  "Width"
Punctuation:  ","
Text:  " "
Name.Variable:  "Ht"
Punctuation:  "})"
Text:  " "
Operator:  "->"
Text:  " "
Name.Variable:  "Width"
Text:  " "
Operator:  "*"
Text:  " "
Name.Variable:  "Ht"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "area"
Punctuation:  "({"
Name:  "circle"
Punctuation:  ","
Text:  " "
Name.Variable:  "R"
Punctuation:  "})"
Text:  "            "
Operator:  "->"
Text:  " "
Literal.Number.Integer:  "3"
Punctuation:  "."
Literal.Number.Integer:  "14159"
Text:  " "
Operator:  "*"
Text:  " "
Name.Variable:  "R"
Text:  " "
Operator:  "*"
Text:  " "
Name.Variable:  "R"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% Compile the code in the file geometry.erl.<newline>"
Name.Function:  "c"
Punctuation:  "("
Name:  "geometry"
Punctuation:  ")."
Text:  "  "
Comment:  "% {ok,geometry}<newline>"
Text:  "<newline>"
Comment:  "% We need to include the module name together with the function name in order to<newline>% identify exactly which function we want to call.<newline>"
Name.Namespace:  "geometry"
Punctuation:  ":"
Name.Function:  "area"
Punctuation:  "({"
Name:  "rectangle"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "10"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "5"
Punctuation:  "})."
Text:  "  "
Comment:  "% 50<newline>"
Name.Namespace:  "geometry"
Punctuation:  ":"
Name.Function:  "area"
Punctuation:  "({"
Name:  "circle"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "1"
Punctuation:  "."
Literal.Number.Integer:  "4"
Punctuation:  "})."
Text:  "  "
Comment:  "% 6.15752<newline>"
Text:  "<newline>"
Comment:  "% In Erlang, two functions with the same name and different arity in the same<newline>% module represent entirely different functions.<newline>"
Punctuation:  "-"
Name.Entity:  "module"
Punctuation:  "("
Name:  "lib_misc"
Punctuation:  ")."
Text:  "<newline>"
Punctuation:  "-"
Name.Entity:  "export"
Punctuation:  "(["
Name:  "sum"
Operator:  "/"
Literal.Number.Integer:  "1"
Punctuation:  "])."
Text:  "<newline>"
Name.Function:  "sum"
Punctuation:  "("
Name.Variable:  "L"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Function:  "sum"
Punctuation:  "("
Name.Variable:  "L"
Punctuation:  ","
Text:  " "
Literal.Number.Integer:  "0"
Punctuation:  ")."
Text:  "<newline>"
Name.Function:  "sum"
Punctuation:  "([],"
Text:  " "
Name.Variable:  "N"
Punctuation:  ")"
Text:  "    "
Operator:  "->"
Text:  " "
Name.Variable:  "N"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "sum"
Punctuation:  "(["
Name.Variable:  "H"
Punctuation:  "|"
Name.Variable:  "T"
Punctuation:  "],"
Text:  " "
Name.Variable:  "N"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Function:  "sum"
Punctuation:  "("
Name.Variable:  "T"
Punctuation:  ","
Text:  " "
Name.Variable:  "H"
Operator:  "+"
Name.Variable:  "N"
Punctuation:  ")."
Text:  "<newline><newline>"
Comment:  "% Funs are \"anonymous\" functions. They are called this because they have no<newline>% name.<newline>"
Name.Variable:  "Double"
Text:  " "
Operator:  "="
Text:  " "
Keyword:  "fun"
Punctuation:  "("
Name.Variable:  "X"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Literal.Number.Integer:  "2"
Operator:  "*"
Name.Variable:  "X"
Text:  " "
Keyword:  "end"
Punctuation:  "."
Text:  "<newline>"
Name.Variable:  "Double"
Punctuation:  "("
Literal.Number.Integer:  "2"
Punctuation:  ")."
Text:  "  "
Comment:  "% 4<newline>"
Text:  "<newline>"
Comment:  "% Functions accept funs as their arguments and can return funs.<newline>"
Name.Variable:  "Mult"
Text:  " "
Operator:  "="
Text:  " "
Keyword:  "fun"
Punctuation:  "("
Name.Variable:  "Times"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "("
Text:  " "
Keyword:  "fun"
Punctuation:  "("
Name.Variable:  "X"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Variable:  "X"
Text:  " "
Operator:  "*"
Text:  " "
Name.Variable:  "Times"
Text:  " "
Keyword:  "end"
Text:  " "
Punctuation:  ")"
Text:  " "
Keyword:  "end"
Punctuation:  "."
Text:  "<newline>"
Name.Variable:  "Triple"
Text:  " "
Operator:  "="
Text:  " "
Name.Variable:  "Mult"
Punctuation:  "("
Literal.Number.Integer:  "3"
Punctuation:  ")."
Text:  "<newline>"
Name.Variable:  "Triple"
Punctuation:  "("
Literal.Number.Integer:  "5"
Punctuation:  ")."
Text:  "  "
Comment:  "% 15<newline>"
Text:  "<newline>"
Comment:  "% List comprehensions are expressions that create lists without having to use<newline>% funs, maps, or filters.<newline>% The notation `[F(X) || X <- L]` means \"the list of `F(X)` where `X` is taken<newline>% from the list `L`.\"<newline>"
Name.Variable:  "L"
Text:  " "
Operator:  "="
Text:  " "
Punctuation:  "["
Literal.Number.Integer:  "1"
Punctuation:  ","
Literal.Number.Integer:  "2"
Punctuation:  ","
Literal.Number.Integer:  "3"
Punctuation:  ","
Literal.Number.Integer:  "4"
Punctuation:  ","
Literal.Number.Integer:  "5"
Punctuation:  "]."
Text:  "<newline>"
Punctuation:  "["
Literal.Number.Integer:  "2"
Operator:  "*"
Name.Variable:  "X"
Text:  " "
Punctuation:  "||"
Text:  " "
Name.Variable:  "X"
Text:  " "
Operator:  "<-"
Text:  " "
Name.Variable:  "L"
Punctuation:  "]."
Text:  "  "
Comment:  "% [2,4,6,8,10]<newline>"
Text:  "<newline>"
Comment:  "% Guards are constructs that we can use to increase the power of pattern<newline>% matching. Using guards, we can perform simple tests and comparisons on the<newline>% variables in a pattern.<newline>% You can use guards in the heads of function definitions where they are<newline>% introduced by the `when` keyword, or you can use them at any place in the<newline>% language where an expression is allowed.<newline>"
Name.Function:  "max"
Punctuation:  "("
Name.Variable:  "X"
Punctuation:  ","
Text:  " "
Name.Variable:  "Y"
Punctuation:  ")"
Text:  " "
Keyword:  "when"
Text:  " "
Name.Variable:  "X"
Text:  " "
Operator:  ">"
Text:  " "
Name.Variable:  "Y"
Text:  " "
Operator:  "->"
Text:  " "
Name.Variable:  "X"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "max"
Punctuation:  "("
Name.Variable:  "X"
Punctuation:  ","
Text:  " "
Name.Variable:  "Y"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Variable:  "Y"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% A guard is a series of guard expressions, separated by commas (`,`).<newline>% The guard `GuardExpr1, GuardExpr2, ..., GuardExprN` is true if all the guard<newline>% expressions `GuardExpr1, GuardExpr2, ...` evaluate to true.<newline>"
Name.Function:  "is_cat"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Keyword:  "when"
Text:  " "
Name.Builtin:  "is_atom"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  "),"
Text:  " "
Name.Variable:  "A"
Text:  " "
Operator:  "=:="
Text:  " "
Name:  "cat"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "true"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "is_cat"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "false"
Punctuation:  "."
Text:  "<newline>"
Name.Function:  "is_dog"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Keyword:  "when"
Text:  " "
Name.Builtin:  "is_atom"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  "),"
Text:  " "
Name.Variable:  "A"
Text:  " "
Operator:  "=:="
Text:  " "
Name:  "dog"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "true"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "is_dog"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "false"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% A `guard sequence` is either a single guard or a series of guards, separated<newline>%by semicolons (`;`). The guard sequence `G1; G2; ...; Gn` is true if at least<newline>% one of the guards `G1, G2, ...` evaluates to true.<newline>"
Name.Function:  "is_pet"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Keyword:  "when"
Text:  " "
Name.Function:  "is_dog"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ");"
Text:  " "
Name.Function:  "is_cat"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "true"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "is_pet"
Punctuation:  "("
Name.Variable:  "A"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "false"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% Records provide a method for associating a name with a particular element in a<newline>% tuple.<newline>% Record definitions can be included in Erlang source code files or put in files<newline>% with the extension `.hrl`, which are then included by Erlang source code<newline>% files.<newline>"
Punctuation:  "-"
Name.Entity:  "record"
Punctuation:  "("
Name.Label:  "todo"
Punctuation:  ","
Text:  " "
Punctuation:  "{"
Text:  "<newline>  "
Name:  "status"
Text:  " "
Operator:  "="
Text:  " "
Name:  "reminder"
Punctuation:  ","
Text:  "  "
Comment:  "% Default value<newline>"
Text:  "  "
Name:  "who"
Text:  " "
Operator:  "="
Text:  " "
Name:  "joe"
Punctuation:  ","
Text:  "<newline>  "
Name:  "text"
Text:  "<newline>"
Punctuation:  "})."
Text:  "<newline><newline>"
Comment:  "% We have to read the record definitions into the shell before we can define a<newline>% record. We use the shell function `rr` (short for read records) to do this.<newline>"
Name.Function:  "rr"
Punctuation:  "("
Literal.String:  "\"records.hrl\""
Punctuation:  ")."
Text:  "  "
Comment:  "% [todo]<newline>"
Text:  "<newline>"
Comment:  "% Creating and updating records:<newline>"
Name.Variable:  "X"
Text:  " "
Operator:  "="
Text:  " "
Name.Label:  "#todo"
Punctuation:  "{}."
Text:  "<newline>"
Comment:  "% #todo{status = reminder, who = joe, text = undefined}<newline>"
Name.Variable:  "X1"
Text:  " "
Operator:  "="
Text:  " "
Name.Label:  "#todo"
Punctuation:  "{"
Name:  "status"
Text:  " "
Operator:  "="
Text:  " "
Name:  "urgent"
Punctuation:  ","
Text:  " "
Name:  "text"
Text:  " "
Operator:  "="
Text:  " "
Literal.String:  "\"Fix errata in book\""
Punctuation:  "}."
Text:  "<newline>"
Comment:  "% #todo{status = urgent, who = joe, text = \"Fix errata in book\"}<newline>"
Name.Variable:  "X2"
Text:  " "
Operator:  "="
Text:  " "
Name.Variable:  "X1"
Name.Label:  "#todo"
Punctuation:  "{"
Name:  "status"
Text:  " "
Operator:  "="
Text:  " "
Name:  "done"
Punctuation:  "}."
Text:  "<newline>"
Comment:  "% #todo{status = done,who = joe,text = \"Fix errata in book\"}<newline>"
Text:  "<newline>"
Comment:  "% `case` expressions.<newline>% `filter` returns a list of all those elements `X` in `L` for which `P(X)` is<newline>% true.<newline>"
Name.Function:  "filter"
Punctuation:  "("
Name.Variable:  "P"
Punctuation:  ","
Text:  " "
Punctuation:  "["
Name.Variable:  "H"
Punctuation:  "|"
Name.Variable:  "T"
Punctuation:  "])"
Text:  " "
Operator:  "->"
Text:  "<newline>  "
Keyword:  "case"
Text:  " "
Name.Variable:  "P"
Punctuation:  "("
Name.Variable:  "H"
Punctuation:  ")"
Text:  " "
Keyword:  "of"
Text:  "<newline>    "
Name:  "true"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "["
Name.Variable:  "H"
Punctuation:  "|"
Name.Function:  "filter"
Punctuation:  "("
Name.Variable:  "P"
Punctuation:  ","
Text:  " "
Name.Variable:  "T"
Punctuation:  ")];"
Text:  "<newline>    "
Name:  "false"
Text:  " "
Operator:  "->"
Text:  " "
Name.Function:  "filter"
Punctuation:  "("
Name.Variable:  "P"
Punctuation:  ","
Text:  " "
Name.Variable:  "T"
Punctuation:  ")"
Text:  "<newline>  "
Keyword:  "end"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "filter"
Punctuation:  "("
Name.Variable:  "P"
Punctuation:  ","
Text:  " "
Punctuation:  "[])"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "[]."
Text:  "<newline><newline>"
Comment:  "% `if` expressions.<newline>"
Name.Function:  "max"
Punctuation:  "("
Name.Variable:  "X"
Punctuation:  ","
Text:  " "
Name.Variable:  "Y"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  "<newline>  "
Keyword:  "if"
Text:  "<newline>    "
Name.Variable:  "X"
Text:  " "
Operator:  ">"
Text:  " "
Name.Variable:  "Y"
Text:  " "
Operator:  "->"
Text:  " "
Name.Variable:  "X"
Punctuation:  ";"
Text:  "<newline>    "
Name.Variable:  "X"
Text:  " "
Operator:  "<"
Text:  " "
Name.Variable:  "Y"
Text:  " "
Operator:  "->"
Text:  " "
Name.Variable:  "Y"
Punctuation:  ";"
Text:  "<newline>    "
Name:  "true"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "nil"
Punctuation:  ";"
Text:  "<newline>  "
Keyword:  "end"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% Warning: at least one of the guards in the if expression must evaluate to true;<newline>% otherwise, an exception will be raised.<newline>"
Text:  "<newline><newline>"
Comment:  "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<newline>%% 3. Exceptions.<newline>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<newline>"
Text:  "<newline>"
Comment:  "% Exceptions are raised by the system when internal errors are encountered or<newline>% explicitly in code by calling `throw(Exception)`, `exit(Exception)` or<newline>% `erlang:error(Exception)`.<newline>"
Name.Function:  "generate_exception"
Punctuation:  "("
Literal.Number.Integer:  "1"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name:  "a"
Punctuation:  ";"
Text:  "<newline>"
Name.Function:  "generate_exception"
Punctuation:  "("
Literal.Number.Integer:  "2"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Function:  "throw"
Punctuation:  "("
Name:  "a"
Punctuation:  ");"
Text:  "<newline>"
Name.Function:  "generate_exception"
Punctuation:  "("
Literal.Number.Integer:  "3"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Builtin:  "exit"
Punctuation:  "("
Name:  "a"
Punctuation:  ");"
Text:  "<newline>"
Name.Function:  "generate_exception"
Punctuation:  "("
Literal.Number.Integer:  "4"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "{"
Name:  "'EXIT'"
Punctuation:  ","
Text:  " "
Name:  "a"
Punctuation:  "};"
Text:  "<newline>"
Name.Function:  "generate_exception"
Punctuation:  "("
Literal.Number.Integer:  "5"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Name.Namespace:  "erlang"
Punctuation:  ":"
Name.Function:  "error"
Punctuation:  "("
Name:  "a"
Punctuation:  ")."
Text:  "<newline><newline>"
Comment:  "% Erlang has two methods of catching an exception. One is to enclose the call to<newline>% the function, which raised the exception within a `try...catch` expression.<newline>"
Name.Function:  "catcher"
Punctuation:  "("
Name.Variable:  "N"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  "<newline>  "
Keyword:  "try"
Text:  " "
Name.Function:  "generate_exception"
Punctuation:  "("
Name.Variable:  "N"
Punctuation:  ")"
Text:  " "
Keyword:  "of"
Text:  "<newline>    "
Name.Variable:  "Val"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "{"
Name.Variable:  "N"
Punctuation:  ","
Text:  " "
Name:  "normal"
Punctuation:  ","
Text:  " "
Name.Variable:  "Val"
Punctuation:  "}"
Text:  "<newline>  "
Keyword:  "catch"
Text:  "<newline>    "
Name.Namespace:  "throw"
Punctuation:  ":"
Name.Variable:  "X"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "{"
Name.Variable:  "N"
Punctuation:  ","
Text:  " "
Name:  "caught"
Punctuation:  ","
Text:  " "
Name:  "thrown"
Punctuation:  ","
Text:  " "
Name.Variable:  "X"
Punctuation:  "};"
Text:  "<newline>    "
Name.Builtin:  "exit"
Punctuation:  ":"
Name.Variable:  "X"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "{"
Name.Variable:  "N"
Punctuation:  ","
Text:  " "
Name:  "caught"
Punctuation:  ","
Text:  " "
Name:  "exited"
Punctuation:  ","
Text:  " "
Name.Variable:  "X"
Punctuation:  "};"
Text:  "<newline>    "
Name.Namespace:  "error"
Punctuation:  ":"
Name.Variable:  "X"
Text:  " "
Operator:  "->"
Text:  " "
Punctuation:  "{"
Name.Variable:  "N"
Punctuation:  ","
Text:  " "
Name:  "caught"
Punctuation:  ","
Text:  " "
Name:  "error"
Punctuation:  ","
Text:  " "
Name.Variable:  "X"
Punctuation:  "}"
Text:  "<newline>  "
Keyword:  "end"
Punctuation:  "."
Text:  "<newline><newline>"
Comment:  "% The other is to enclose the call in a `catch` expression. When you catch an<newline>% exception, it is converted into a tuple that describes the error.<newline>"
Name.Function:  "catcher"
Punctuation:  "("
Name.Variable:  "N"
Punctuation:  ")"
Text:  " "
Operator:  "->"
Text:  " "
Keyword:  "catch"
Text:  " "
Name.Function:  "generate_exception"
Punctuation:  "("
Name.Variable:  "N"
Punctuation:  ")."
Text:  "<newline>"
