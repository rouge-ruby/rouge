Comment:  "\"======================================================================<newline>|<newline>|   Python-like Generators<newline>|<newline>|<newline> ======================================================================\""
Text:  "<newline><newline><newline>"
Comment:  "\"======================================================================<newline>|<newline>| Copyright 2003 Free Software Foundation, Inc.<newline>| Written by Paolo Bonzini.<newline>|<newline>| This file is part of GNU Smalltalk.<newline>|<newline>| GNU Smalltalk is free software; you can redistribute it and/or modify it<newline>| under the terms of the GNU General Public License as published by the Free<newline>| Software Foundation; either version 2, or (at your option) any later version.<newline>| <newline>| GNU Smalltalk is distributed in the hope that it will be useful, but WITHOUT<newline>| ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS<newline>| FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more<newline>| details.<newline>| <newline>| You should have received a copy of the GNU General Public License along with<newline>| GNU Smalltalk; see the file COPYING.  If not, write to the Free Software<newline>| Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  <newline>|<newline> ======================================================================\""
Text:  "<newline><newline>"
Name.Class:  "Stream"
Text:  " "
Name.Function:  "subclass:"
Text:  " "
Literal.String.Symbol:  "#Generator"
Text:  "<newline>\t  "
Name.Function:  "instanceVariableNames:"
Text:  " "
Literal.String:  "'next topContext bottomContext contexts suspendedContext atEnd'"
Text:  "<newline>\t  "
Name.Function:  "classVariableNames:"
Text:  " "
Literal.String:  "''"
Text:  "<newline>\t  "
Name.Function:  "poolDictionaries:"
Text:  " "
Literal.String:  "''"
Text:  "<newline>\t  "
Name.Function:  "category:"
Text:  " "
Literal.String:  "'Streams-Generators'"
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Class:  "Generator"
Text:  " "
Name.Function:  "comment:"
Text:  "<newline>"
Literal.String:  "'A Generator object provides a way to define a Generator method: such<newline>a method does not return a single value, instead it returns an object<newline>(the Generator) that uses a Stream interface to access multiple<newline>return values.  The return values are computed one at a time, as<newline>needed, and hence need not even be finite.<newline><newline>A generator methods starts by creating a Generator object with<newline>\"Generator new\" and saving it into a temporary variable.  As soon as<newline>this is executed, even though it is not apparent, the method exits<newline>returning the newly created Generator.  As soon as a message like<newline>#next, #peek, #atEnd or #peekFor: is sent to the generator, execution<newline>of the method that created it resumes and goes on until the<newline>generator''s #yield: method is called: then the argument of #yield:<newline>will be the Generator''s next element.  If the generator method goes<newline>on to the end without calling #yield:, the Generator will produce no<newline>more elements and #atEnd will return true.<newline><newline>Alternatively, a generator block can be converted to a Generator with<newline>\"Generator on: [...]\".  The Generator itself is passed to the block<newline>and, again, the block starts its execution when a message like<newline>#next, #peek, #atEnd or #peekFor: is sent to the generator.  Again,<newline>the block''s execution is temporarily suspended when the<newline>generator''s #yield: method is called.<newline><newline>Returning a value from the generator method makes no sense at least<newline>after \"Generator new\" is invoked.  Before, you can use it to return a<newline>different kind of Stream, or nil, or whatever else; after, the value<newline>returned will not matter and the return will put an end to the<newline>Generator''s production of elements.<newline><newline>You could achieve the effect of generators manually by writing your<newline>own class and storing all the local variables of the generator as<newline>instance variables.  For example, returning a list of integers could<newline>be done by setting a variable to 0, and having the #next method<newline>increment it and return it.  However, for a moderately complicated<newline>generator, writing a corresponding class would be much messier (and<newline>might lead to code duplication or inefficiency if you want to support<newline>#peek, #peekFor: and/or #atEnd): in general, providing a #do:-like<newline>interface is easy, but not providing a Stream-like one (think binary<newline>trees).<newline><newline>The idea of generators comes from other programming languages, in<newline>particular this interface looks much like Scheme streams and Python<newline>generators.  But Python in turn mutuated the idea for example from<newline>Icon, where the idea of generators is central.  In Icon, every<newline>expression and function call behaves like a generator, and if a<newline>statement manages scalars, it automatically uses up all the results<newline>that the corresponding generator provides; on the other hand, Icon<newline>does not represent generators as first-class objects like Python and<newline>Smalltalk do.'"
Name.Function:  "!"
Text:  "<newline><newline>"
Punctuation:  "!"
Name.Class:  "Generator"
Text:  " "
Name.Function:  "class"
Text:  " "
Name.Function:  "methodsFor:"
Text:  " "
Literal.String:  "'instance creation'"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "new"
Text:  "<newline>    "
Comment:  "\"Return a generator, and also suspend the execution of the<newline>     sender by returning the new generator to the method that<newline>     invoked the sender.  More easily seen by looking at an<newline>     example:<newline><newline>     Integer>>evenNumbersUpTo: n<newline>         | gen |<newline>         gen := Generator new.<newline>         self to: n do: [ :each |<newline>             each even ifTrue: [ gen yield: each ]<newline>         ]<newline><newline>     Although there is no return statement in the method, evaluating<newline>     it returns a Generator for the even numbers between the receiver<newline>     and the argument.\""
Text:  "<newline>    "
Operator:  "^"
Name.Builtin.Pseudo:  "super"
Text:  " "
Name.Builtin:  "new"
Text:  "<newline>\t"
Name.Function:  "context:"
Text:  " "
Name.Builtin.Pseudo:  "thisContext"
Text:  " "
Name.Function:  "parentContext"
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "on:"
Text:  " "
Name.Variable:  "aBlock"
Text:  "<newline>    "
Punctuation:  "|"
Name.Variable:  " gen "
Punctuation:  "|"
Text:  "<newline>    "
Name.Variable:  "gen"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Builtin:  "new"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "aBlock"
Text:  " "
Name.Function:  "value:"
Text:  " "
Name.Variable:  "gen"
Punctuation:  "."
Text:  "<newline>"
Keyword:  "! !"
Text:  "<newline><newline>"
Punctuation:  "!"
Name.Class:  "Generator"
Text:  " "
Name.Function:  "methodsFor:"
Text:  " "
Literal.String:  "'stream protocol'"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "atEnd"
Text:  "<newline>    "
Comment:  "\"Answer whether more data can be generated.\""
Text:  "<newline>    "
Name.Variable:  "atEnd"
Text:  " "
Name.Function:  "isNil"
Text:  " "
Name.Builtin:  "ifTrue:"
Text:  " "
Punctuation:  "["
Text:  " "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "generateNext"
Text:  " "
Punctuation:  "]."
Text:  "<newline>    "
Operator:  "^"
Name.Variable:  "atEnd"
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "next"
Text:  "<newline>    "
Comment:  "\"Evaluate the generator until it generates the next value or<newline>     decides that nothing else can be generated.\""
Text:  "<newline>    "
Punctuation:  "|"
Name.Variable:  " result "
Punctuation:  "|"
Text:  "<newline>    "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "atEnd"
Text:  " "
Name.Builtin:  "ifTrue:"
Text:  " "
Punctuation:  "["
Text:  " "
Operator:  "^"
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "pastEnd"
Text:  " "
Punctuation:  "]."
Text:  "<newline>    "
Name.Variable:  "atEnd"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "nil"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "result"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "next"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "next"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "nil"
Punctuation:  "."
Text:  "<newline>    "
Operator:  "^"
Name.Variable:  "result"
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "peek"
Text:  "<newline>    "
Comment:  "\"Evaluate the generator until it generates the next value or<newline>     decides that nothing else can be generated, and save the value<newline>     so that #peek or #next will return it again.\""
Text:  "<newline>    "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "atEnd"
Text:  " "
Name.Builtin:  "ifTrue:"
Text:  " "
Punctuation:  "["
Text:  " "
Operator:  "^"
Name.Builtin.Pseudo:  "nil"
Text:  " "
Punctuation:  "]."
Text:  "<newline>    "
Operator:  "^"
Name.Variable:  "next"
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "peekFor:"
Text:  " "
Name.Variable:  "anObject"
Text:  "<newline>    "
Comment:  "\"Evaluate the generator until it generates the next value or<newline>     decides that nothing else can be generated, and if it is not equal<newline>     to anObject, save the value so that #peek or #next will return it<newline>     again.\""
Text:  "<newline>    "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "atEnd"
Text:  " "
Name.Builtin:  "ifTrue:"
Text:  " "
Punctuation:  "["
Text:  " "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "pastEnd"
Punctuation:  "."
Text:  " "
Operator:  "^"
Name.Builtin.Pseudo:  "false"
Text:  " "
Punctuation:  "]."
Text:  "<newline>    "
Operator:  "^"
Name.Variable:  "next"
Text:  " "
Name.Function:  "="
Text:  " "
Name.Variable:  "anObject"
Text:  "<newline>        "
Name.Builtin:  "ifTrue:"
Text:  " "
Punctuation:  "["
Text:  " "
Name.Variable:  "next"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "nil"
Punctuation:  "."
Text:  " "
Name.Variable:  "atEnd"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "nil"
Punctuation:  "."
Text:  " "
Name.Builtin.Pseudo:  "true"
Text:  " "
Punctuation:  "]"
Text:  "<newline>        "
Name.Builtin:  "ifFalse:"
Text:  " "
Punctuation:  "["
Text:  " "
Name.Builtin.Pseudo:  "false"
Text:  " "
Punctuation:  "]"
Text:  "<newline>"
Keyword:  "! !"
Text:  "<newline><newline>"
Name.Function:  "!"
Name.Class:  "Generator"
Text:  " "
Name.Function:  "methodsFor:"
Text:  " "
Literal.String:  "'private - continuations'"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "context:"
Text:  " "
Name.Variable:  "aContext"
Text:  "<newline>    "
Comment:  "\"Initialize the state of the generator.  Its execution will<newline>     resume from the context, aContext.  Then return the generator<newline>     itself to the sender of aContext: this method is called by<newline>     Generator class>>#new, and this has the side effect of<newline>     returning the Generator from the sender.\""
Text:  "<newline>    "
Name.Variable:  "contexts"
Text:  " "
Operator:  ":="
Text:  " "
Name.Class:  "OrderedCollection"
Text:  " "
Name.Builtin:  "new"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "topContext"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "bottomContext"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "aContext"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "bottomContext"
Text:  " "
Name.Function:  "parentContext"
Text:  " "
Name.Function:  "continue:"
Text:  " "
Name.Builtin.Pseudo:  "self"
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "yield:"
Text:  " "
Name.Variable:  "anObject"
Text:  "<newline>    "
Comment:  "\"Save the object returned by the continuation in the next<newline>     instance variable, then save the execution state of the<newline>     continuation in topContext, bottomContext and contexts.<newline>     This is because resuming execution in #invokeGenerator<newline>     will cause returned blocks to be marked as non-returnable,<newline>     and we want to preserve the chain.\""
Text:  "<newline>    "
Name.Variable:  "next"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "anObject"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "atEnd"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "false"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "topContext"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "bottomContext"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "thisContext"
Text:  " "
Name.Function:  "parentContext"
Punctuation:  "."
Text:  "<newline>    "
Punctuation:  "["
Text:  "<newline>\t"
Name.Variable:  "contexts"
Text:  " "
Name.Function:  "addLast:"
Text:  " "
Name.Variable:  "bottomContext"
Punctuation:  "."
Text:  "<newline>\t"
Name.Variable:  "bottomContext"
Text:  " "
Name.Function:  "parentContext"
Text:  " "
Name.Function:  "=="
Text:  " "
Name.Variable:  "suspendedContext"
Text:  "<newline>    "
Punctuation:  "]"
Text:  " "
Name.Builtin:  "whileFalse:"
Text:  " "
Punctuation:  "["
Text:  "<newline>\t"
Name.Variable:  "bottomContext"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "bottomContext"
Text:  " "
Name.Function:  "parentContext"
Punctuation:  "."
Text:  "<newline>    "
Punctuation:  "]."
Text:  "<newline>    "
Name.Variable:  "suspendedContext"
Text:  " "
Name.Function:  "continue:"
Text:  " "
Name.Builtin.Pseudo:  "self"
Punctuation:  "."
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Variable:  "generateNext"
Text:  "<newline>    "
Comment:  "\"Invoke the continuation via #invokeGenerator,<newline>     then resume execution when #yield: is invoked.  Then,<newline>     use the information in the contexts instance variable<newline>     to reconstruct the continuation's chain of contexts.\""
Text:  "<newline>    "
Punctuation:  "|"
Name.Variable:  " ctx "
Punctuation:  "|"
Text:  "<newline>    "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "invokeGenerator"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "ctx"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "topContext"
Punctuation:  "."
Text:  "<newline>    "
Punctuation:  "["
Text:  " "
Name.Variable:  "contexts"
Text:  " "
Name.Function:  "isEmpty"
Text:  " "
Punctuation:  "]"
Text:  " "
Name.Builtin:  "whileFalse:"
Text:  " "
Punctuation:  "["
Text:  "<newline>\t"
Name.Variable:  "ctx"
Text:  " "
Name.Function:  "parentContext:"
Text:  " "
Name.Variable:  "contexts"
Text:  " "
Name.Function:  "removeFirst"
Punctuation:  "."
Text:  "<newline>\t"
Name.Variable:  "ctx"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "ctx"
Text:  " "
Name.Function:  "parentContext"
Punctuation:  "."
Text:  "<newline>    "
Punctuation:  "]."
Text:  "<newline>"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Variable:  "invokeGenerator"
Text:  "<newline>    "
Comment:  "\"This swizzles the contexts, inserting the execution state of<newline>     the continuation between the #invokeGenerator context and<newline>     the #generateNext context, then starts evaluating the code<newline>     in the continuation.\""
Text:  "<newline><newline>    "
Name.Variable:  "atEnd"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "true"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "suspendedContext"
Text:  " "
Operator:  ":="
Text:  " "
Name.Builtin.Pseudo:  "thisContext"
Text:  " "
Name.Function:  "parentContext"
Punctuation:  "."
Text:  "<newline>    "
Name.Variable:  "bottomContext"
Text:  " "
Name.Function:  "parentContext:"
Text:  " "
Name.Variable:  "suspendedContext"
Punctuation:  "."
Text:  "<newline>    "
Name.Builtin.Pseudo:  "thisContext"
Text:  " "
Name.Function:  "parentContext:"
Text:  " "
Name.Variable:  "topContext"
Punctuation:  "."
Text:  "<newline>"
Keyword:  "! !"
Text:  "<newline><newline>"
Punctuation:  "!"
Name.Class:  "Integer"
Text:  " "
Name.Function:  "methodsFor:"
Text:  " "
Literal.String:  "'examples of generators'"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "generatorForGeneratorExample"
Text:  "<newline>    "
Punctuation:  "|"
Name.Variable:  " gen "
Punctuation:  "|"
Text:  "<newline>    "
Name.Variable:  "gen"
Text:  " "
Operator:  ":="
Text:  " "
Name.Class:  "Generator"
Text:  " "
Name.Builtin:  "new"
Punctuation:  "."
Text:  "<newline>    "
Literal.String:  "'Entering gen'"
Text:  " "
Name.Function:  "displayNl"
Punctuation:  "."
Text:  "<newline>    "
Literal.Number:  "1"
Text:  " "
Name.Function:  "to:"
Text:  " "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "do:"
Text:  " "
Punctuation:  "["
Text:  " "
Operator:  ":"
Name.Variable:  "each"
Text:  " "
Punctuation:  "|"
Text:  "<newline>\t"
Punctuation:  "("
Literal.String:  "'Yielding '"
Name.Function:  ","
Text:  " "
Name.Variable:  "each"
Text:  " "
Name.Function:  "printString,"
Text:  " "
Literal.String:  "'... '"
Punctuation:  ")"
Text:  " "
Name.Function:  "display"
Punctuation:  "."
Text:  "<newline>\t"
Name.Variable:  "gen"
Text:  " "
Name.Function:  "yield:"
Text:  " "
Name.Variable:  "each"
Punctuation:  "."
Text:  "<newline>\t"
Literal.String:  "'Resuming gen'"
Text:  " "
Name.Function:  "displayNl"
Text:  "<newline>    "
Punctuation:  "]"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "generatorBlockExample"
Text:  "<newline>    "
Operator:  "^"
Name.Class:  "Generator"
Text:  " "
Name.Function:  "on:"
Text:  " "
Punctuation:  "["
Text:  " "
Operator:  ":"
Name.Variable:  "gen"
Text:  " "
Punctuation:  "|"
Text:  "<newline>        "
Literal.String:  "'Entering gen'"
Text:  " "
Name.Function:  "displayNl"
Punctuation:  "."
Text:  "<newline>        "
Literal.Number:  "1"
Text:  " "
Name.Function:  "to:"
Text:  " "
Name.Builtin.Pseudo:  "self"
Text:  " "
Name.Function:  "do:"
Text:  " "
Punctuation:  "["
Text:  " "
Operator:  ":"
Name.Variable:  "each"
Text:  " "
Punctuation:  "|"
Text:  "<newline>\t    "
Punctuation:  "("
Literal.String:  "'Yielding '"
Name.Function:  ","
Text:  " "
Name.Variable:  "each"
Text:  " "
Name.Function:  "printString,"
Text:  " "
Literal.String:  "'... '"
Punctuation:  ")"
Text:  " "
Name.Function:  "display"
Punctuation:  "."
Text:  "<newline>\t    "
Name.Variable:  "gen"
Text:  " "
Name.Function:  "yield:"
Text:  " "
Name.Variable:  "each"
Punctuation:  "."
Text:  "<newline>\t    "
Literal.String:  "'Resuming gen'"
Text:  " "
Name.Function:  "displayNl"
Text:  "<newline>        "
Punctuation:  "]"
Text:  " "
Punctuation:  "]"
Name.Function:  "!"
Text:  "<newline><newline>"
Name.Function:  "generatorExample:"
Text:  " "
Name.Variable:  "gen"
Text:  "<newline>    "
Punctuation:  "|"
Name.Variable:  " n "
Punctuation:  "|"
Text:  "<newline>    "
Punctuation:  "("
Literal.String:  "'Running on '"
Name.Function:  ","
Text:  " "
Name.Variable:  "gen"
Text:  " "
Name.Function:  "printString"
Punctuation:  ")"
Text:  " "
Name.Function:  "displayNl"
Punctuation:  "."
Text:  "<newline>    "
Punctuation:  "["
Text:  "<newline>\t"
Literal.String:  "'Calling next... '"
Text:  " "
Name.Function:  "display"
Punctuation:  "."
Text:  "<newline>\t"
Name.Variable:  "n"
Text:  " "
Operator:  ":="
Text:  " "
Name.Variable:  "gen"
Text:  " "
Name.Function:  "next"
Punctuation:  "."
Text:  "<newline>\t"
Name.Variable:  "n"
Text:  " "
Name.Function:  "notNil"
Text:  "<newline>    "
Punctuation:  "]"
Text:  " "
Name.Builtin:  "whileTrue:"
Text:  " "
Punctuation:  "["
Text:  "<newline>\t"
Punctuation:  "("
Literal.String:  "'Got '"
Name.Function:  ","
Text:  " "
Name.Variable:  "n"
Text:  " "
Name.Function:  "printString"
Punctuation:  ")"
Text:  " "
Name.Function:  "displayNl"
Text:  "<newline>    "
Punctuation:  "]"
Keyword:  "! !"
Text:  "<newline><newline>"
Literal.Number:  "10"
Text:  " "
Name.Function:  "generatorExample:"
Text:  " "
Literal.Number:  "10"
Text:  " "
Name.Function:  "generatorForGeneratorExample!"
Text:  "<newline>"
Name.Class:  "Eval"
Text:  " "
Punctuation:  "["
Text:  "<newline>    "
Name.Class:  "Smalltalk"
Text:  " "
Name.Function:  "byteCodeCounter"
Text:  " "
Name.Function:  "printNl"
Punctuation:  "."
Text:  "<newline>    "
Literal.Number:  "10"
Text:  " "
Name.Function:  "generatorExample:"
Text:  " "
Literal.Number:  "10"
Text:  " "
Name.Function:  "generatorBlockExample"
Punctuation:  "."
Text:  "<newline>    "
Name.Class:  "Smalltalk"
Text:  " "
Name.Function:  "byteCodeCounter"
Text:  " "
Name.Function:  "printNl"
Text:  "<newline>"
Punctuation:  "]"
Text:  "<newline>"
