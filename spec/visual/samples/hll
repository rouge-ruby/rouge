// Some comment

/* A multiline
   comment */

namespaces: N {
  constants:
    int foo := 5;
    
    int 'foo' := 5;
    int "foo" := 5;
}

types:
  enum {red, blue} colour;
  sort {flower, grass} < herbs;
  sort {larch, oak} < trees;
  sort herbs, trees < plants;
  int[0,5] five;
  int signed 5 int5;
  int unsigned 5 uint5;
  tuple {bool, bool} bool2;
  struct {x: int5, y: int5} point5;
  bool ^ (N::foo, N::"foo", N::'foo') foo_matrix;
  (int5 * int5 -> int5) fct5;

declarations:
  bool it;
  int5 noise;
  bool cohabit(herbs, trees);
  (plants -> bool) edible;
  plants winlose[int5,int5];
  int5 projx(point5);
  int5 projy(point5);
  bool g(bool, bool);

definitions:
  projx(p) := p.x;
  projy(p) := p.y;

constraints:
  ALL x:point5 (projx(x) + noise <> X(noise));
  SOME x:int5 (projx(point5) == noise);
  SOME h: herbs ALL p: plants (cohabit(h,p));
  if it & pre(it, false) then edible(flower) else edible(grass);
  winlose[3,2] == oak;
  winlose[2,3] <> X(winlose[2,3]);
  I(g(false, False));
  SOME p:point5 (projx(p) = 3 # projy(p) = 3);
